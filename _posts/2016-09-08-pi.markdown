---
layout: post
title: Использование Docker для кросс-компиляции под Raspberry Pi (и других целей)
date: 2016-09-08 16:00:00 +0300
excerpt_separator: <!--more-->
tags: [перевод, hackaday, docker, raspberry pi]
---

На летней школе [FabLab](http://fablab61.ru/) так и не добрались до *Docker* и кросс-компиляции под *Raspberry Pi*, поэтому для интересующихся я сделал перевод вводной статьи на эту тему.

Источник [здесь](http://hackaday.com/2016/09/01/how-to-use-docker-to-cross-compile-for-raspberry-pi-and-more/).

<!--more-->

Настраивать окружение для кросс-компиляции скучно и утомительно. Конечно, вы можете компилировать непосредственно на *Raspberry Pi*, но иногда всё же нужен "большой" компьютер (да и работать так можно вообще без *Pi* под рукой - например, в самолёте). Настроить кросс-компиляцию для всех необходимых инструментов - весьма сложная процедура, но, если вы выполните один простой шаг, она станет очень лёгкой даже вне зависимости от того, на какой машине вы работаете. Этот простой шаг - установка *Docker*.

*Docker* доступен для *Linux*, *Windows* и *Mac OS*. Он позволяет разработчикам создавать образы окружения *Linux*, предварительно настроенного для запуска какого-либо сервиса. Как и вирутальные машины, образы могут быть запущены на одном хосте и никак не будут мешать друг другу. Но, в отличие от виртуальных машин, контейнеры *Docker* (запущенные образы) легковесны, потому что используют ядро и аппаратную часть хоста.

Конечно, с появлением *Docker* настроить окружение для сборки под *Raspberry Pi* не стало легче. Но эта работа уже сделана за вас другими разработчиками, и *Docker* позволяет вам автоматически скачивать и обновлять их настройки.

Если вы используете *Linux*, ваш менеджер пакетов, возможно, упростит настройку кросс-компиляции и без *Docker* (подробно об этом способе вы можете узнать [здесь](https://hackaday.com/2016/02/03/code-craft-cross-compiling-for-the-raspberry-pi/)). Однако, преимущество образов *Docker* в том, что они представляют полностью изолированное окружение, которое вы можете легко переносить между разыми машинами и платформами (*Windows* и *Mac* используют разные хитрости для запуска окружения *Linux*, но это выполняется прозрачно).

## Установка *Docker*

Если вы не используете *Linux*, вам придётся разобраться как установить *Docker* на вашей платформе. Существует несколько способов сделать это на *Windows* (в зависимости от того, какую версию *Windows* вы используете), а с *Mac* я не сталкивался. На *Linux* вы, наверняка, сможете установить всё, что вам необходимо, с помощью пакетного менеджера.

Для *Ubuntu* и подобных дистрибутивов можно подумать, что необходимо установить пакет `docker`. Это разумно, но не верно. Пакет `docker` содержит панель системного трея для оконных менеждеров, которые таковой не имеют. На самом деле, вам нужен пакет `docker.io`:

{% highlight shell %}
$ sudo apt-get install docker.io
{% endhighlight %}

При установке будет выведен список дополнительных пакетов - добавьте параметр `--install-suggests` если хотите установить их.

*Docker* состоит из двух частей - демона (процесса, запущенного в фоновом режиме) и консольного клиента *docker*. Для тех, кто предпочитает графический интерфейс, существует несколько GUI-клиентов, но я не могу ничего сказать о них, потому что использую командную строку.

## Образ для кросс-компиляции

Команда *Docker* поддерживает репозиторий образов, называемый [Docker Hub](https://hub.docker.com/). Если у вас нет нужного образа на локальном диске, клиент *Docker* будет, по-умолчанию, искать его там. Для наших целей понадобится образ `sdthirlwall/raspberry-pi-cross-compiler:legacy-trusty`. Весьма длинное название, поэтому разработчики образа предоставляют удобный скрипт, который работает в большинстве случаев. Как получить скрипт? Использовать *Docker*, разумеется.

Кстати говоря, по умолчанию, клиент *Docker* должен быть запущен от *root*'а, но вы можете [создать специальную группу](https://docs.docker.com/engine/installation/linux/ubuntulinux/#create-a-docker-group), если вас это не устраивает (`sudo` тоже нормально работает).

Команда для получения скрипта выглядит следующим образом:

{% highlight shell %}
$ sudo docker run \
sdthirlwall/raspberry-pi-cross-compiler:legacy-trusty >rpxc
{% endhighlight %}

Так как у вас, скорее всего, ещё нет указанного образа на диске, клиенту *Docker* потребуется время чтобы скачать его и завершить выполнение команды. В следующий раз клиент использует локальную копию и всё пройдёт быстрее.

Установите флаг исполнения для полученного скрипта:

{% highlight shell %}
$ chmod +x rpxc
{% endhighlight %}

И перересите его в директорию из вашего окружения, если не хотите обращаться к нему по полному имени.

Если вы хотите детальнее познакомиться с проектом, помочь или следить за разработкой, загляните на их [GitHub-репозиторий](https://github.com/sdt/docker-raspberry-pi-cross-compiler).

## Использование

Скрипт `rpxc` запускает полученную команду в новом окружении. Он использует *Docker*, поэтому вам нужно быть *root*'ом или состоять в группе *Docker*. Сборка проводится (почти) привычными средствами:

{% highlight shell %}
$ rpxc rpxc-gcc -o hello-world hello-world.c
{% endhighlight %}

Или, если у вас есть Makefile:

{% highlight shell %}
$ rpxc make
{% endhighlight %}

Ваша текущая директория в момент запуска `rpxc` становится директорией `/build` в новом окружении, в которой и происходит сборка.

Ленивые могут запустить оболочку внутри контейнера:

$ rpxc bash

И делать всё без лишних телодвижений. Выполните

{% highlight shell %}
$ ls /usr/local/bin/rpxc*
{% endhighlight %}

чтобы увидеть список доступных инструментов.

`rpxc` может использоваться для обновления образа и самого себя, для этого служит команда `update`. Команды `update-image` и `update-script` позволяют обновить только образ или скрипт, соответственно.

## Docking

Существует много других полезных образов. Заведите аккаунт на *Docker Hub* - когда вы это сделаете, может показаться, что образов маловато. Но попробуйте поискать, например *Raspberry* или *Arduino* - получите большое количество преднастроенных окружений. Поищите также *ESP8266* - вам понравится. Есть [образ](https://hub.docker.com/r/nickandrew/eagle/) даже для программы разработки печатных плат *CadSoft Eagle*!
